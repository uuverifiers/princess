Loading existential.pri ...
Preprocessing ...
Constructing satisfying assignment for the existential constants ...

VALID

Under the assignment:
b9 & b8 & !b7 & b6 & !b5 & !b4 & !b3 & !b2 & !b1 & !b0
Loading bvsdiv.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsdiv2.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsdiv3.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsdiv5.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsdiv6.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsdiv6b.smt2 ...
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun x () (_ BitVec 8) (_ bv32 8))
  (define-fun d () (_ BitVec 8) (_ bv31 8))
  (define-fun c () (_ BitVec 8) (_ bv31 8))
)
Loading bvsdiv6c.smt2 ...
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun x () (_ BitVec 8) (_ bv127 8))
)
Loading bvsdiv7.smt2 ...
Warning: get-model is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun r4 () (_ BitVec 8) (_ bv3 8))
  (define-fun r3 () (_ BitVec 8) (_ bv253 8))
  (define-fun r2 () (_ BitVec 8) (_ bv253 8))
  (define-fun r1 () (_ BitVec 8) (_ bv3 8))
)
Loading bvsmod.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsmod3.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsrem.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvsrem2.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvshl1.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvshl2.smt2 ...
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun y () (_ BitVec 8) (_ bv0 8))
  (define-fun x () (_ BitVec 8) (_ bv8 8))
)
Loading bvshl3.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvshl4.smt2 ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 40), simplifying (58), interpolating ...

unsat
(
  (bvule (_ bv3 8) x)
  (and (bvule x (_ bv6 8)) (bvule (_ bv3 8) x))
  (bvule (_ bv8 8) y)
)
Loading shift2.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
b = 4294967295.\as[bv[32]] & a = 4294966272.\as[bv[32]]
Loading shift3.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
b = 0.\as[bv[32]] & a = 100.\as[bv[32]]
Loading shift5.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
y = 0.\as[signed bv[16]] & x = 0.\as[signed bv[16]]
Loading shift6.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
y = (-5).\as[signed bv[16]] & x = 0.\as[signed bv[16]]
Loading shift7.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
iX = 30.\as[signed bv[32]]
Loading shift8.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
Y = 6
Loading shift9.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
x = 0.\as[bv[32]]
Loading shift10.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
z = 268435455.\as[bv[32]] & y = 4.\as[bv[32]] & x = 4294967295.\as[bv[32]]
Loading shift11.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
z = 268435455.\as[bv[32]] & y = 4.\as[bv[32]] & x = 4294967295.\as[bv[32]]
Loading shift12.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading shift12b.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading shift12c.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading shift13.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading shift14.smt2 ...
Preprocessing ...
Constructing satisfying assignment for the existential constants ...

unsat
Loading bench_977.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun T1_572572 () (_ BitVec 8) (_ bv0 8))
)
Loading bench_977b.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun T1_572572 () (_ BitVec 8) (_ bv0 8))
)
Loading bench_977c.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun T1_572572 () (_ BitVec 8) (_ bv6 8))
)
Loading bench_977d.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun T1_572572 () (_ BitVec 8) (_ bv112 8))
)
Loading bench_977e.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun T1_572572 () (_ BitVec 8) (_ bv64 8))
)
Loading rewriting_cycle.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
inv_main23_4_0 = 2147483647 & inv_main23_3_0 = 2147483646 & inv_main23_2_0 = 2 & inv_main23_1_0 = -2147483644 & inv_main23_0_0 = 2147483647 & inv_main15_4_0 = 2147483647 & inv_main15_3_0 = 2147483647 & inv_main15_2_0 = 2 & inv_main15_1_0 = 2 & inv_main15_0_0 = 2147483647
Loading nested_casts.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading Primes_true-unreach-call.c_2207.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Proving negated formula ...

unsat
Loading simple-extracts.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
y = 115.\as[bv[8]] & x = 231.\as[bv[8]]
Loading simple-concat.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
z = 1099511627775.\as[bv[40]] & y = 255.\as[bv[8]] & x = 255.\as[bv[8]]
Loading simple-concat2.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading bv-ops.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
z = 1.\as[bv[3]] & y = 3.\as[bv[3]] & x = 5.\as[bv[3]]
Loading bv-ops2.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
z = 243.\as[bv[8]] & x = 255.\as[bv[8]]
Loading bv-ops3.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading bv-ops3b.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading bv-ops4.pri ...
Preprocessing ...
Constructing countermodel ...

INVALID

Countermodel:
x = 15.\as[bv[4]]
Loading bv-ops5.pri ...
Preprocessing ...
Constructing satisfying assignment for the existential constants ...

VALID

Under the assignment:
y = 4043309055.\as[bv[32]] & x = 4043309055.\as[bv[32]]
Loading bitops-1.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

unsat
Loading bitops.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

unsat
Loading bitops1.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

unsat
Loading concatcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading concat.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading concore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading ext_con_004_001_0016.smt2 ...
Warning: exit is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

unsat
Loading extractcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading intcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading intsplitcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading mycore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading smallcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading smallercore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading splitcore.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading split-diseq.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading example13.pri ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 17), simplifying (38), interpolating ...

VALID

Interpolants:
x[5:2] != 6.\as[bv[4]]
Loading example13.smt2 ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 17), simplifying (38), interpolating ...

unsat
(
  (not (= ((_ extract 5 2) x) (_ bv6 4)))
)
Loading bvcomp.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading problem_24.smt2 ...
Preprocessing ...
Constructing countermodel ...

sat
(model
)
Loading large_shift.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvashr.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat
Loading bvashr2.smt2 ...
Warning: get-model is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun y2 () (_ BitVec 128) (_ bv340282366920938463463374607431768211455 128))
  (define-fun x2 () (_ BitVec 128) (_ bv340282366920938463463374607431768211455 128))
  (define-fun y () (_ BitVec 128) (_ bv0 128))
  (define-fun x () (_ BitVec 128) (_ bv170141183460469231731687303715884105727 128))
)
Loading arith-extracts.pri ...
Preprocessing ...
Constructing countermodel ...

VALID
Loading bvsrem-bug.smt2 ...
Preprocessing ...
Constructing satisfying assignment for the existential constants ...

unsat
Loading reducer-bug.smt2 ...
Preprocessing ...
Constructing satisfying assignment for the existential constants ...

unsat
Loading bv-ops3c.pri ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 42)

VALID

Assumptions after simplification:
---------------------------------

  (input)
  3 >= x & x >= 0 & \exists int v0, v1; (1 >= v1 & v1 >= 0 & 1 >= v0 & v0 >= 0 &
    x[1:1] = v1 & x[0:0] = v0 & \exists int v2; (3 >= v2 & v2 >= 0 & v2[1:1] = 1
      - v1 & v2[0:0] = 1 - v0 & \exists int v3, v4, v5; (-1*v5 + -1*v1 >= -1 &
        v1 >= v5 & 1 >= v5 & v5 >= 0 & -1*v4 + -1*v0 >= -1 & v0 >= v4 & 1 >= v4
        & v4 >= 0 & 3 >= v3 & v3 >= 1 & v3[1:1] = v5 & v3[0:0] = v4)))

Those formulas are unsatisfiable:
---------------------------------

Begin of proof
| 
| ALPHA: (input) implies:
|   (1)  \exists int v0, v1; (1 >= v1 & v1 >= 0 & 1 >= v0 & v0 >= 0 & x[1:1] =
|          v1 & x[0:0] = v0 & \exists int v2; (3 >= v2 & v2 >= 0 & v2[1:1] = 1 -
|            v1 & v2[0:0] = 1 - v0 & \exists int v3, v4, v5; (-1*v5 + -1*v1 >=
|              -1 & v1 >= v5 & 1 >= v5 & v5 >= 0 & -1*v4 + -1*v0 >= -1 & v0 >=
|              v4 & 1 >= v4 & v4 >= 0 & 3 >= v3 & v3 >= 1 & v3[1:1] = v5 &
|              v3[0:0] = v4)))
| 
| DELTA: instantiating (1) with fresh symbols all_2_0, all_2_1 gives:
|   (2)  1 >= all_2_0 & all_2_0 >= 0 & 1 >= all_2_1 & all_2_1 >= 0 & x[1:1] =
|        all_2_0 & x[0:0] = all_2_1 & \exists int v0; (3 >= v0 & v0 >= 0 &
|          v0[1:1] = 1 - all_2_0 & v0[0:0] = 1 - all_2_1 & \exists int v1, v2,
|          v3; (-1*v3 + -1*all_2_0 >= -1 & all_2_0 >= v3 & 1 >= v3 & v3 >= 0 &
|            -1*v2 + -1*all_2_1 >= -1 & all_2_1 >= v2 & 1 >= v2 & v2 >= 0 & 3 >=
|            v1 & v1 >= 1 & v1[1:1] = v3 & v1[0:0] = v2))
| 
| ALPHA: (2) implies:
|   (3)  \exists int v0; (3 >= v0 & v0 >= 0 & v0[1:1] = 1 - all_2_0 & v0[0:0] =
|          1 - all_2_1 & \exists int v1, v2, v3; (-1*v3 + -1*all_2_0 >= -1 &
|            all_2_0 >= v3 & 1 >= v3 & v3 >= 0 & -1*v2 + -1*all_2_1 >= -1 &
|            all_2_1 >= v2 & 1 >= v2 & v2 >= 0 & 3 >= v1 & v1 >= 1 & v1[1:1] =
|            v3 & v1[0:0] = v2))
| 
| DELTA: instantiating (3) with fresh symbol all_5_0 gives:
|   (4)  3 >= all_5_0 & all_5_0 >= 0 & all_5_0[1:1] = 1 - all_2_0 & all_5_0[0:0]
|        = 1 - all_2_1 & \exists int v0, v1, v2; (-1*v2 + -1*all_2_0 >= -1 &
|          all_2_0 >= v2 & 1 >= v2 & v2 >= 0 & -1*v1 + -1*all_2_1 >= -1 &
|          all_2_1 >= v1 & 1 >= v1 & v1 >= 0 & 3 >= v0 & v0 >= 1 & v0[1:1] = v2
|          & v0[0:0] = v1)
| 
| ALPHA: (4) implies:
|   (5)  \exists int v0, v1, v2; (-1*v2 + -1*all_2_0 >= -1 & all_2_0 >= v2 & 1
|          >= v2 & v2 >= 0 & -1*v1 + -1*all_2_1 >= -1 & all_2_1 >= v1 & 1 >= v1
|          & v1 >= 0 & 3 >= v0 & v0 >= 1 & v0[1:1] = v2 & v0[0:0] = v1)
| 
| DELTA: instantiating (5) with fresh symbols all_8_0, all_8_1, all_8_2 gives:
|   (6)  -1*all_8_0 + -1*all_2_0 >= -1 & all_2_0 >= all_8_0 & 1 >= all_8_0 &
|        all_8_0 >= 0 & -1*all_8_1 + -1*all_2_1 >= -1 & all_2_1 >= all_8_1 & 1
|        >= all_8_1 & all_8_1 >= 0 & 3 >= all_8_2 & all_8_2 >= 1 & all_8_2[1:1]
|        = all_8_0 & all_8_2[0:0] = all_8_1
| 
| ALPHA: (6) implies:
|   (7)  all_8_2 >= 1
|   (8)  3 >= all_8_2
|   (9)  all_8_1 >= 0
|   (10)  all_2_1 >= all_8_1
|   (11)  -1*all_8_1 + -1*all_2_1 >= -1
|   (12)  all_2_0 >= all_8_0
|   (13)  -1*all_8_0 + -1*all_2_0 >= -1
|   (14)  all_8_2[0:0] = all_8_1
|   (15)  all_8_2[1:1] = all_8_0
| 
| THEORY_AXIOM ModuloArithmetic: 
Warning: type clash during inference: bv[1] vs int
Warning: type clash during inference: bv[1] vs int
|   (16)  \forall int v0; \forall any v1, v2; (v0[1:1] != v2 | v0[0:0] != v1 |
|           v0.\as[bv[2]] = 2*v2 + v1)
| 
| GROUND_INST: instantiating (16) with all_8_2, all_8_1, all_8_0, simplifying
|              with (14), (15) gives:
|   (17)  all_8_2.\as[bv[2]] = 2*all_8_0 + all_8_1
| 
| THEORY_AXIOM ModuloArithmetic: 
|   (18)  \forall int v0, v1, v2; (2*v2 + v1 = v0 | 3 < v0 | v0 < 1 |
|           v0.\as[bv[2]] != 2*v2 + v1)
| 
| GROUND_INST: instantiating (18) with all_8_2, all_8_1, all_8_0, simplifying
|              with (17) gives:
|   (19)  2*all_8_0 + all_8_1 = all_8_2 | 3 < all_8_2 | all_8_2 < 1
| 
| BETA: splitting (19) gives:
| 
| Case 1:
| | 
| |   (20)  0 >= all_8_2
| | 
| | COMBINE_INEQS: (7), (20) imply:
| |   (21)  false
| | 
| | CLOSE: (21) is inconsistent.
| | 
| Case 2:
| | 
| |   (22)  2*all_8_0 + all_8_1 = all_8_2 | 3 < all_8_2
| | 
| | BETA: splitting (22) gives:
| | 
| | Case 1:
| | | 
| | |   (23)  all_8_2 >= 4
| | | 
| | | COMBINE_INEQS: (8), (23) imply:
| | |   (24)  false
| | | 
| | | CLOSE: (24) is inconsistent.
| | | 
| | Case 2:
| | | 
| | |   (25)  2*all_8_0 + all_8_1 = all_8_2
| | | 
| | | REDUCE: (13), (25) imply:
| | |   (26)  all_8_0 + all_8_1 - all_8_2 - all_2_0 >= -1
| | | 
| | | REDUCE: (12), (25) imply:
| | |   (27)  all_8_0 + all_8_1 - all_8_2 + all_2_0 >= 0
| | | 
| | | COL_REDUCE: introducing fresh symbol sc_17_1_0 defined by:
| | |   (28)  all_8_0 - all_8_2 = sc_17_1_0
| | | 
| | | COMBINE_EQS: (25), (28) imply:
| | |   (29)  all_8_1 + all_8_2 = -2*sc_17_1_0
| | | 
| | | REDUCE: (26), (28), (29) imply:
| | |   (30)  -1*all_8_2 + -1*sc_17_1_0 - all_2_0 >= -1
| | | 
| | | REDUCE: (27), (28), (29) imply:
| | |   (31)  -1*all_8_2 + -1*sc_17_1_0 + all_2_0 >= 0
| | | 
| | | REDUCE: (11), (29) imply:
| | |   (32)  all_8_2 + 2*sc_17_1_0 - all_2_1 >= -1
| | | 
| | | REDUCE: (10), (29) imply:
| | |   (33)  all_8_2 + 2*sc_17_1_0 + all_2_1 >= 0
| | | 
| | | REDUCE: (9), (29) imply:
| | |   (34)  -2*sc_17_1_0 >= all_8_2
| | | 
| | | COMBINE_INEQS: (30), (32) imply:
| | |   (35)  sc_17_1_0 - all_2_0 - all_2_1 >= -2
| | | 
| | | COMBINE_INEQS: (31), (32) imply:
| | |   (36)  sc_17_1_0 + all_2_0 - all_2_1 >= -1
| | | 
| | | COMBINE_INEQS: (30), (33) imply:
| | |   (37)  sc_17_1_0 - all_2_0 + all_2_1 >= -1
| | | 
| | | COMBINE_INEQS: (31), (33) imply:
| | |   (38)  sc_17_1_0 + all_2_0 + all_2_1 >= 0
| | | 
| | | COMBINE_INEQS: (7), (34) imply:
| | |   (39)  -1 >= sc_17_1_0
| | | 
| | | SIMP: (39) implies:
| | |   (40)  -1 >= sc_17_1_0
| | | 
| | | COMBINE_INEQS: (35), (40) imply:
| | |   (41)  -1*all_2_0 + -1*all_2_1 >= -1
| | | 
| | | COMBINE_INEQS: (37), (40) imply:
| | |   (42)  all_2_1 >= all_2_0
| | | 
| | | COMBINE_INEQS: (36), (40) imply:
| | |   (43)  all_2_0 >= all_2_1
| | | 
| | | COMBINE_INEQS: (38), (40) imply:
| | |   (44)  all_2_0 + all_2_1 >= 1
| | | 
| | | COMBINE_INEQS: (41), (43) imply:
| | |   (45)  0 >= all_2_1
| | | 
| | | SIMP: (45) implies:
| | |   (46)  0 >= all_2_1
| | | 
| | | COMBINE_INEQS: (42), (44) imply:
| | |   (47)  all_2_1 >= 1
| | | 
| | | SIMP: (47) implies:
| | |   (48)  all_2_1 >= 1
| | | 
| | | COMBINE_INEQS: (46), (48) imply:
| | |   (49)  false
| | | 
| | | CLOSE: (49) is inconsistent.
| | | 
| | End of split
| | 
| End of split
| 
End of proof
Loading bvsdiv6.smt2 ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 830)

unsat
Loading bvsrem2.smt2 ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 161)

unsat
