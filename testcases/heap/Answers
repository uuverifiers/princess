Loading simple-heap.smt2 ...
Preprocessing ...
Constructing countermodel ...

unsat

Loading bug-model-1.smt2 ...
Warning: get-model is only supported in incremental mode (option +incremental), ignoring it
Preprocessing ...
Constructing countermodel ...

sat
(model
  (define-fun A2 () addr (nthaddr 1))
  (define-fun A () addr (nthaddr 2))
  (define-fun H () heap (newheap (alloc (newheap (alloc emptyheap defObj)) defObj)))
)

Loading read-interpolation.smt2 ...
Preprocessing ...
Constructing countermodel ...
Found proof (size 24), simplifying (40), interpolating ...

unsat
(
  (= (getInt (read h2 a)) 42)
)

Loading incremental-heap.smt2 ...
unsat
unsat
sat
(model
  (define-fun A2 () addr (nthaddr 2))
  (define-fun A () addr (nthaddr 1))
  (define-fun H2 () heap (newheap (alloc (newheap (alloc emptyheap defObj)) (Wrappedsimple (simple 42)))))
  (define-fun H () heap (newheap (alloc emptyheap (WrappedInt 10))))
)
Loading swap-interpolation.smt2 ...
unsat
unsat
((and (and (and (not (= z y)) (not (= z x))) (and (and (<= 0 (+ (- 1) z)) (<= 0 (+ (- 1) y))) (<= 0 (+ (- 1) x)))) (and (and (<= 0 (+ (counteraddr H) (* (- 1) z))) (<= 0 (+ (counteraddr H) (* (- 1) y)))) (and (and (<= 0 (+ (counteraddr H) (* (- 1) z))) (<= 0 (+ (counteraddr H) (* (- 1) y)))) (<= 0 (+ (counteraddr H) (* (- 1) x))))))
(and (and (not (= z x)) (and (and (<= 0 (+ (- 1) z)) (<= 0 (+ (- 1) y))) (<= 0 (+ (- 1) x)))) (and (and (and (and (<= 0 (+ (counteraddr H1) (* (- 1) x))) (or (and (= (read H1 z) (read H y)) (= (read H1 y) (read H y))) (and (= (read H1 y) (read H y)) (or (not (= y x)) (not (= (read H x) (read H y))))))) (and (<= 0 (+ (counteraddr H1) (* (- 1) x))) (or (and (= (read H1 z) (read H y)) (= (read H1 y) (read H y))) (and (= (read H1 y) (read H y)) (or (not (= y x)) (not (= (read H x) (read H y)))))))) (<= 0 (+ (counteraddr H1) (* (- 1) y)))) (= (read H x) (read H1 z))))
(and (and (<= 0 (+ (- 1) y)) (= (read H x) (read H2 z))) (and (or (and (and (= (read H2 x) (read H y)) (<= 0 (+ (- 1) x))) (or (not (= (read H y) (read H2 z))) (not (= y x)))) (and (and (= (read H2 x) (read H2 z)) (= (read H y) (read H2 z))) (<= 0 (+ (- 1) x)))) (<= 0 (+ (counteraddr H2) (* (- 1) y)))))
(and (= (read H3 x) (read H y)) (= (read H x) (read H3 y))))

HeapTests1
================================================================================
Test 1: All locations on the empty heap are unallocated.
--------------------------------------------------------------------------------
Step 1.1 (expected: Unsat)
  valid(emptyheap, p) --> Unsat
--------------------------------------------------------------------------------
Step 1.2 (expected: Sat)
  !valid(emptyheap, p) --> Sat
================================================================================
================================================================================
Test 2: For all heaps, null pointer always points to an unallocated location.
--------------------------------------------------------------------------------
Step 2.1 (expected: Unsat)
  valid(h, nulladdr) --> Unsat
================================================================================
================================================================================
Test 3: For all heaps, trying to read the null pointer returns the defined object.
--------------------------------------------------------------------------------
Step 3.1 (expected: Unsat)
  read(h, nulladdr) != defObj --> Unsat
--------------------------------------------------------------------------------
Step 3.2 (expected: Sat)
  read(h, nulladdr) = defObj --> Sat
================================================================================
================================================================================
Test 4: For all heaps, writing to the null pointer returns the original heap.
--------------------------------------------------------------------------------
Step 4.1 (expected: Unsat)
  write(h, nulladdr, o) != h --> Unsat
--------------------------------------------------------------------------------
Step 4.2 (expected: Sat)
  write(h, nulladdr, o) = h --> Sat
================================================================================
================================================================================
Test 5: After alloc, the returned pointer points to an allocated address.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  alloc(h, o) = ar
--------------------------------------------------------------------------------
Step 5.1 (expected: Sat)
  valid(newheap(ar), newaddr(ar)) --> Sat
--------------------------------------------------------------------------------
Step 5.2 (expected: Unsat)
  !valid(newheap(ar), newaddr(ar)) --> Unsat
================================================================================
================================================================================
Test 6: After alloc, previously allocated addresses are the same in both heaps.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  alloc(h, o) = ar
--------------------------------------------------------------------------------
Step 6.1 (expected: Unsat)
  valid(h, p) & !valid(newheap(ar), p) --> Unsat
--------------------------------------------------------------------------------
Step 6.2 (expected: Unsat)
  p != newaddr(ar) &
  !valid(h, p) &
  valid(newheap(ar), p) --> Unsat
================================================================================
================================================================================
Test 7: Deterministic allocation
--------------------------------------------------------------------------------
Step 7.1 (expected: Unsat)
  \forall addr v0; (valid(h, v0) <-> valid(h1, v0)) &
  alloc(h, o) = ar &
  alloc(h1, o') = ar' &
  newaddr(ar) != newaddr(ar') --> Unsat
================================================================================
================================================================================
Test 8: Reading from a previously written (alloc.) location returns that value.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  valid(h, p)
--------------------------------------------------------------------------------
Step 8.1 (expected: Sat)
  read(write(h, p, o), p) = o --> Sat
--------------------------------------------------------------------------------
Step 8.2 (expected: Unsat)
  read(write(h, p, o), p) != o --> Unsat
================================================================================
================================================================================
Test 9: Reading a newly allocated location returns the allocated value
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  ar = alloc(h, o)
--------------------------------------------------------------------------------
Step 9.1 (expected: Sat)
  read(newheap(ar), newaddr(ar)) = o --> Sat
--------------------------------------------------------------------------------
Step 9.2 (expected: Unsat)
  read(newheap(ar), newaddr(ar)) != o --> Unsat
================================================================================
================================================================================
Test 10: Allocation does not modify any of the values on the old heap
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  ar = alloc(h, o)
  p != newaddr(ar)
--------------------------------------------------------------------------------
Step 10.1 (expected: Sat)
  read(newheap(ar), p) = read(h, p) --> Sat
--------------------------------------------------------------------------------
Step 10.2 (expected: Unsat)
  read(newheap(ar), p) != read(h, p) --> Unsat
================================================================================
================================================================================
Test 11: Reading a newly allocated location returns the allocated value (v2)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  alloc(h, o) = ar
  h1 = newheap(ar)
  p = newaddr(ar)
--------------------------------------------------------------------------------
Step 11.1 (expected: Sat)
  read(h1, p) = o --> Sat
--------------------------------------------------------------------------------
Step 11.2 (expected: Unsat)
  read(h1, p) != o --> Unsat
================================================================================
================================================================================
Test 12: Reading an unallocated location returns the defined object
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  !valid(h, p)
--------------------------------------------------------------------------------
Step 12.1 (expected: Sat)
  read(h, p) = defObj --> Sat
--------------------------------------------------------------------------------
Step 12.2 (expected: Unsat)
  read(h, p) != defObj --> Unsat
================================================================================
================================================================================
Test 13: Writing to a location does not modify the rest of the locations
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  p != p'
  valid(h, p)
  valid(h, p')
--------------------------------------------------------------------------------
Step 13.1 (expected: Sat)
  read(write(h, p', o), p) = read(h, p) --> Sat
--------------------------------------------------------------------------------
Step 13.2 (expected: Unsat)
  read(write(h, p', o), p) != read(h, p) --> Unsat
================================================================================
================================================================================
Test 14: Writing to an unallocated location returns the same heap.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  !valid(h, p)
--------------------------------------------------------------------------------
Step 14.1 (expected: Sat)
  write(h, p, o) = h --> Sat
--------------------------------------------------------------------------------
Step 14.2 (expected: Unsat)
  write(h, p, o) != h --> Unsat
--------------------------------------------------------------------------------
Common assertion: 
  h != emptyheap
--------------------------------------------------------------------------------
Step 14.3 (expected: Sat)
  write(h, p, o) = h & h != emptyheap --> Sat
--------------------------------------------------------------------------------
Step 14.4 (expected: Unsat)
  write(h, p, o) != h --> Unsat
--------------------------------------------------------------------------------
Common assertion: 
  p != nulladdr
--------------------------------------------------------------------------------
Step 14.5 (expected: Sat)
  write(h, p, o) = h --> Sat
--------------------------------------------------------------------------------
Step 14.6 (expected: Unsat)
  write(h, p, o) != h --> Unsat
================================================================================
================================================================================
Test 15: Allocating and dereferencing pointer to pointer.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  alloc(emptyheap, WrappedInt(42)) = ar & p = newaddr(ar) & h = newheap(ar)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  alloc(h, WrappedAddr(p)) = ar' & p' = newaddr(ar') & h1 = newheap(ar')
--------------------------------------------------------------------------------
Step 15.1 (expected: Sat)
  read(h, getAddr(read(h1, p'))) = WrappedInt(42) --> Sat
--------------------------------------------------------------------------------
Step 15.2 (expected: Unsat)
  read(h, getAddr(read(h1, p'))) != WrappedInt(42) --> Unsat
================================================================================
================================================================================
Test 16: Extensionality over write
--------------------------------------------------------------------------------
Step 16.1 (expected: Sat)
  write(h, p, o) = write(write(h, p, o'), p, o) --> Sat
--------------------------------------------------------------------------------
Step 16.2 (expected: Unsat)
  write(h, p, o) != write(write(h, p, o'), p, o) --> Unsat
================================================================================
================================================================================
Test 17: Extensionality over write (exclude empty heaps)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  h != emptyheap
--------------------------------------------------------------------------------
Step 17.1 (expected: Sat)
  write(h, p, o) = write(write(h, p, o'), p, o) --> Sat
--------------------------------------------------------------------------------
Step 17.2 (expected: Unsat)
  write(h, p, o) != write(write(h, p, o'), p, o) --> Unsat
================================================================================
================================================================================
Test 18: Extensionality over write (exclude empty heaps and null addresses)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  h != emptyheap & p != nulladdr
--------------------------------------------------------------------------------
Step 18.1 (expected: Sat)
  write(h, p, o) = write(write(h, p, o'), p, o) --> Sat
--------------------------------------------------------------------------------
Step 18.2 (expected: Unsat)
  write(h, p, o) != write(write(h, p, o'), p, o) --> Unsat
================================================================================
================================================================================
Test 19: Extensionality over write (only valid writes)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  valid(h, p)
--------------------------------------------------------------------------------
Step 19.1 (expected: Sat)
  write(h, p, o) = write(write(h, p, o'), p, o) --> Sat
--------------------------------------------------------------------------------
Step 19.2 (expected: Unsat)
  write(h, p, o) != write(write(h, p, o'), p, o) --> Unsat
================================================================================
================================================================================
Test 20: Extensionality
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  counteraddr(h) = counteraddr(h1) & h != h1
--------------------------------------------------------------------------------
Step 20.1 (expected: Sat)
  \exists addr v0; (valid(h, v0) & read(h, v0) != read(h1, v0)) --> Sat
--------------------------------------------------------------------------------
Step 20.2 (expected: Unsat)
  \forall addr v0; (valid(h, v0) & read(h, v0) = read(h1, v0)) --> Unsat
================================================================================
================================================================================
Test 21: ROW-Upward
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  valid(h, p) & valid(h, p') & p != p'
--------------------------------------------------------------------------------
Step 21.1 (expected: Sat)
  write(write(h, p, WrappedInt(1)), p', WrappedInt(42)) = h1 & write(write(h, p, WrappedInt(2)), p', WrappedInt(42)) = h2 --> Sat
--------------------------------------------------------------------------------
Step 21.2 (expected: Unsat)
  write(write(h, p, WrappedInt(1)), p', WrappedInt(42)) = write(write(h, p, WrappedInt(2)), p', WrappedInt(42)) --> Unsat
================================================================================

HeapTests2
================================================================================
Test 1: Reading back written value after chain allocation and a write.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  ar = alloc(newheap(alloc(emptyheap, WrappedInt(0))), WrappedInt(3))
--------------------------------------------------------------------------------
Step 1.1 (expected: Sat)
  valid(newheap(ar), newaddr(ar)) --> Sat
--------------------------------------------------------------------------------
Step 1.2 (expected: Sat)
  getInt(read(newheap(ar), newaddr(ar))) = 3 --> Sat
--------------------------------------------------------------------------------
Step 1.3 (expected: Unsat)
  getInt(read(newheap(ar), newaddr(ar))) != 3 --> Unsat
--------------------------------------------------------------------------------
Step 1.4 (expected: Sat)
  read(newheap(ar), newaddr(ar)) = WrappedInt(3) --> Sat
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  h = write(newheap(ar), newaddr(ar), WrappedInt(50))
--------------------------------------------------------------------------------
Step 1.5 (expected: Sat)
  read(h, nthaddr(2)) != read(newheap(ar), nthaddr(2)) --> Sat
--------------------------------------------------------------------------------
Step 1.6 (expected: Unsat)
  read(h, nthaddr(2)) = read(newheap(ar), nthaddr(2)) --> Unsat
--------------------------------------------------------------------------------
Step 1.7 (expected: Sat)
  valid(h, newaddr(ar)) --> Sat
--------------------------------------------------------------------------------
Step 1.8 (expected: Unsat)
  getInt(read(h, newaddr(ar))) = 0 --> Unsat
--------------------------------------------------------------------------------
Step 1.9 (expected: Unsat)
  getInt(read(h, newaddr(ar))) = 3 --> Unsat
--------------------------------------------------------------------------------
Step 1.10 (expected: Sat)
  getInt(read(h, newaddr(ar))) != 3 --> Sat
--------------------------------------------------------------------------------
Step 1.11 (expected: Sat)
  read(h, newaddr(ar)) != WrappedInt(3) --> Sat
--------------------------------------------------------------------------------
Step 1.12 (expected: Unsat)
  getInt(read(h, newaddr(ar))) != 50 --> Unsat
--------------------------------------------------------------------------------
Step 1.13 (expected: Sat)
  getInt(read(h, newaddr(ar))) = 50 --> Sat
--------------------------------------------------------------------------------
Step 1.14 (expected: Sat)
  read(h, newaddr(ar)) = WrappedInt(50) --> Sat
================================================================================
================================================================================
Test 2: list-001-fail.c-1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  h = newheap(alloc(emptyheap, WrappedS(struct_S(0))))
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  p1 = newaddr(alloc(emptyheap, WrappedS(struct_S(0))))
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Common assertion: 
  p2 = p1
--------------------------------------------------------------------------------
Step 2.1 (expected: Sat)
  p1 = p2 --> Sat
================================================================================
================================================================================
Test 3: list-001-fail.c-2
--------------------------------------------------------------------------------
Step 3.1 (expected: Sat)
  h1 = emptyheap & h = newheap(alloc(h1, WrappedS(struct_S(0)))) & p1 = newaddr(alloc(h1, WrappedS(struct_S(0)))) & p2 = p1 & x = x(getS(read(h, p2))) --> Sat
================================================================================
================================================================================
Test 4: list-004-fail.c
--------------------------------------------------------------------------------
Step 4.1 (expected: Sat)
  h1 = newheap(alloc(emptyheap, WrappedNode(struct_Node(0)))) & p1 = newaddr(alloc(emptyheap, WrappedNode(struct_Node(0)))) & h = newheap(alloc(h1, p1)) & h2 = write(h, p1, WrappedNode(struct_Node(p1))) --> Sat
================================================================================
